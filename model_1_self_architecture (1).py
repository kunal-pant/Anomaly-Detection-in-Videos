# -*- coding: utf-8 -*-
"""Model 1 Self-Architecture.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VYtEBoxl-rriw0k0qS_C3QGiyr8neD9C
"""

#Mount the drive
from google.colab import drive

drive.mount('/content/gdrive')

#Import the required libraries.

import os
import glob
import keras
import cv2
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from tensorflow.keras.layers import *
from tensorflow.keras.layers import Conv2D
from tensorflow.keras.models import Sequential
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.callbacks import EarlyStopping

"""**Keras Sequence Video generators**

This package proposes some classes to work with Keras (included in TensorFlow) that generates batches of frames from video files.
"""

#Install the Video Generator to feed the videos to the network.
pip install keras-video-generators

from keras_video import VideoFrameGenerator

#Let's see the different classes we have
classes=os.listdir('/content/gdrive/MyDrive/Training Data')
print(classes)

#Let's augment our frames according to our needs

#Specify the parameters according to your needs.
SIZE = (64, 64)
CHANNELS = 3
NBFRAME = 290
#Batch Size
BS = 4       


#Augment the frames as per your needs
data_aug = keras.preprocessing.image.ImageDataGenerator(
    zoom_range=.1,
    horizontal_flip=False,
    rotation_range=8,
    width_shift_range=.2,     
    height_shift_range=.2)

#The glob module is a useful part of the Python standard library. glob (short for global)
# is used to return all file paths that match a specific pattern

glob_pattern='/content/gdrive/MyDrive/Training Data/{classname}/*.mp4'

#This is our train generator.
train = VideoFrameGenerator(
    classes=classes, 
    glob_pattern=glob_pattern,
    nb_frames=NBFRAME,
    split_val=0.15, 
    shuffle=True,
    batch_size=BS,
    target_shape=SIZE,
    nb_channel=CHANNELS,
    transformation=data_aug,
    use_frame_cache=False)

#Get the validation generator.
valid = train.get_validation_generator()

#Let us define a model architecture.

model=Sequential()

model.add(ConvLSTM2D(filters = 4, kernel_size = (3, 3), activation = 'tanh',data_format = "channels_last",
                         recurrent_dropout=0.2, return_sequences=True, input_shape = (NBFRAME,
                                                                                      64, 64, 3)))
model.add(MaxPooling3D(pool_size=(1, 4, 4), padding='same', data_format='channels_last'))
# model.add(TimeDistributed(Dropout(0.2)))

model.add(ConvLSTM2D(filters = 8, kernel_size = (3, 3), activation = 'tanh',data_format = "channels_last",
                         recurrent_dropout=0.2, return_sequences=True))
model.add(MaxPooling3D(pool_size=(1, 4, 4), padding='same', data_format='channels_last'))
# model.add(TimeDistributed(Dropout(0.2)))

model.add(ConvLSTM2D(filters = 14, kernel_size = (3, 3), activation = 'tanh',data_format = "channels_last",
                         recurrent_dropout=0.2, return_sequences=True))
model.add(MaxPooling3D(pool_size=(1, 4, 4), padding='same', data_format='channels_last'))
# model.add(TimeDistributed(Dropout(0.2)))

model.add(Flatten())
model.add(Dense(256, activation = "relu"))
# model.add(Dense(256, activation = "softmax"))
model.add(Dense(2, activation = "sigmoid"))
model.summary()


# Create an Instance of Early Stopping Callback
early_stopping_callback = EarlyStopping(monitor = 'val_loss', patience = 5, mode = 'auto', restore_best_weights = True)

# Compile the model and specify loss function, optimizer and metrics values to the model
model.compile(loss = 'binary_crossentropy', optimizer = 'Adam', metrics = ["accuracy"])

#Let us train the model

model.fit(train, epochs=30,validation_data=valid,verbose=1,callbacks=[early_stopping_callback])

"""Since we are satisfied with the model, let's save it for future use."""

#Let us save the model.

model.save('/content/gdrive/MyDrive/Models./Model_10s_80_acc')

train.classes

pred=model.predict(valid)
pred